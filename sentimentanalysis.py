# -*- coding: utf-8 -*-
"""SentimentAnalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17EY4DpOj_hEhaoqjS3khFOH56pZjv1Kg

# **Movie Review Sentiment Analysis**
This project is a basic sentiment analysis tool using the NLTK movie reviews dataset. It predicts whether a movie review is positive or negative using machine learning.

##  **What This Project Does**

1.Loads movie reviews from the NLTK corpus

2.Preprocesses and vectorizes text data using CountVectorizer

3.Trains a Naive Bayes classifier (MultinomialNB

4.Evaluates accuracy and classification report

5.Predicts sentiment for new input sentences

##**Libraries Used**

*   nltk — for natural language processing and corpus
*   pandas — for data handling
*   scikit-learn — for model building and evaluation\

##**How It Works (Step-by-Step)**

**Step 1** : Install libraries and download NLTK's movie_reviews dataset

**Step 2** : Load and label the reviews as 'pos' or 'neg'

**Step 3** : Convert the reviews into a machine-readable format using CountVectorizer

**Step 4** : Split the data into training and test sets

**Step 5** : Train a Naive Bayes model

**Step 6** : Evaluate model performance (accuracy and classification report)

**Step 7** : Predict sentiment of custom review inputs
"""

!pip install nltk pandas scikit-learn
import nltk
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score, classification_report
from nltk.corpus import movie_reviews
nltk.download('movie_reviews')
documents = [
    (" ".join(movie_reviews.words(fileid)), category)
    for category in movie_reviews.categories()
    for fileid in movie_reviews.fileids(category)
]


df = pd.DataFrame(documents, columns=['review', 'sentiment'])

vectorize = CountVectorizer(max_features=2000)
X = vectorize.fit_transform(df['review'])
y = df['sentiment']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = MultinomialNB()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

print(f"Accuracy: {accuracy_score(y_test, y_pred)}")
print(f"Classification Report:\n{classification_report(y_test, y_pred)}")

def predict_sentiment(text):
    text_vector = vectorize.transform([text])
    prediction = model.predict(text_vector)
    return prediction[0]


print(predict_sentiment("I absolutely loved this movie! It was fantastic."))
print(predict_sentiment("It was a terrible film. I hated it."))
print(predict_sentiment("The movie was okay, nothing special."))

"""The code provided visualizes the distribution of sentiments (positive and negative) in the movie reviews dataset. Here's a description of each part of the code:

##**Importing Libraries:**

The Seaborn library is imported to create statistical visualizations, and Matplotlib is imported for more general plotting functionality. These libraries are commonly used for generating plots and graphs in Python.

##**Creating a Count Plot:**

The sns.countplot() function is used to create a bar plot. It takes the DataFrame df as input and plots the distribution of the 'sentiment' column. The x-axis represents the sentiment labels ('pos' for positive and 'neg' for negative), and the y-axis shows the number of reviews for each sentiment.

##**Customizing the Plot:**

The plot is customized with a title "Sentiment Distribution" to provide context. The x-axis is labeled "Sentiment" to indicate the two possible sentiment categories, and the y-axis is labeled "Number of Reviews" to show how many reviews fall under each sentiment.

##**Displaying the Plot:**

Finally, plt.show() is called to display the plot. This makes the graph appear so you can visually inspect the distribution of sentiments.

##**Purpose:**
This visualization is helpful in understanding how many reviews are positive versus negative. It shows the count of positive and negative reviews in the dataset, which can help you assess whether the dataset is balanced or imbalanced in terms of sentiment distribution. This is crucial information when training a machine learning model, as an imbalanced dataset may lead to biased predictions.T
"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.countplot(data=df, x='sentiment')
plt.title("Sentiment Distribution")
plt.xlabel("Sentiment")
plt.ylabel("Number of Reviews")
plt.show()

"""
This code analyzes and visualizes the most frequently used words in positive and negative movie reviews using the NLTK movie reviews dataset.

##**Step-by-Step Explanation**

**Step 1** : Importing Modules:

collections.Counter is used to count how often each word appears.
numpy is imported for potential numerical operations (though not directly used here).


**Step 2** : Separating Reviews by Sentiment:

The dataset is split into positive and negative reviews based on the 'sentiment' column in the DataFrame.


**Step 3** : Tokenizing and Counting Words:

All reviews from each sentiment category are combined into one big string.
That string is split into individual words (tokens).
Counter() counts how many times each word appears.
The .most_common(20) function returns the top 20 most frequent words in each category.


**Step 4** : Visualizing the Most Common Words:

A custom function plot_top_words() is defined to plot a bar chart using Seaborn.
It takes the word-frequency data and a title, and displays the words on the y-axis and their frequency on the x-axis.
This function is used to show two bar charts:
One for the top 20 words in positive reviews.
One for the top 20 words in negative reviews.

##**Purpose**
* Helps understand which words are most often used in positive vs. negative reviews.

* Useful for sentiment analysis, feature selection, or just exploratory data analysis (EDA).

* Gives insight into the language patterns that might influence the classification of review sentiments.
"""

from collections import Counter
import numpy as np

# Separate reviews by sentiment
pos_reviews = df[df['sentiment'] == 'pos']['review']
neg_reviews = df[df['sentiment'] == 'neg']['review']

# Tokenize and count words
pos_words = " ".join(pos_reviews).split()
neg_words = " ".join(neg_reviews).split()

pos_freq = Counter(pos_words).most_common(20)
neg_freq = Counter(neg_words).most_common(20)

# Plot
def plot_top_words(freq, title):
    words, counts = zip(*freq)
    plt.figure(figsize=(10,5))
    sns.barplot(x=list(counts), y=list(words))
    plt.title(title)
    plt.xlabel("Frequency")
    plt.show()

plot_top_words(pos_freq, "Top 20 Words in Positive Reviews")
plot_top_words(neg_freq, "Top 20 Words in Negative Reviews")

"""##**Confusion Matrix Visualization:**
This code generates and displays a confusion matrix to help evaluate the performance of the sentiment analysis model.

##**What Each Part Does**
**Importing functions:**

* confusion_matrix from sklearn.metrics calculates the confusion matrix.

* ConfusionMatrixDisplay is used to visualize it.

**Creating the confusion matrix:**

* confusion_matrix() compares the true labels (y_test) with the predicted labels (y_pred) to count:

    * True Positives (correct positive predictions)

    * True Negatives (correct negative predictions)

    * False Positives (wrongly predicted as positive)

    * False Negatives (wrongly predicted as negative)

**Displaying the matrix:**

* ConfusionMatrixDisplay() takes the confusion matrix and label names from model.classes_.

* .plot(cmap='Blues') plots the matrix with a blue color scale for better visibility.

* plt.title("Confusion Matrix") adds a title to the plot.

* plt.show() displays the plot.

##**Purpose**

* The confusion matrix gives a detailed breakdown of model accuracy.

* It helps you see where the model is making mistakes, like confusing positive reviews as negative (or vice versa).

* Especially useful when evaluating classifiers on imbalanced datasets.
"""

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

cm = confusion_matrix(y_test, y_pred, labels=model.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=model.classes_)
disp.plot(cmap='Blues')
plt.title("Confusion Matrix")
plt.show()